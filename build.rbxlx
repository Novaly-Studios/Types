<roblox version="4">
  <Item class="ReplicatedFirst" referent="0">
    <Properties>
      <string name="Name">ReplicatedFirst</string>
    </Properties>
    <Item class="ModuleScript" referent="1">
      <Properties>
        <string name="Name">TypeGuard</string>
        <string name="Source">--!nonstrict
-- @TODO This script really needs splitting up into sub-modules

local EMPTY_STRING = ""
local INVALID_ARGUMENT = "Invalid argument #%d (%s expected, got %s)"

local function ExpectType(PassedArg: any, ExpectedType: string, ArgNumber: number)
    local GotType = typeof(PassedArg)
    assert(GotType == ExpectedType, INVALID_ARGUMENT:format(ArgNumber, ExpectedType, GotType))
end

local function CreateStandardInitial(ExpectedTypeName)
    return function(_, Item)
        local ItemType = typeof(Item)

        if (ItemType == ExpectedTypeName) then
            return true, EMPTY_STRING
        end

        return false, "Expected" .. ExpectedTypeName .. ", got " .. ItemType
    end
end

local function ConcatWithToString(Array: {any}, Separator: string): string
    local Result = EMPTY_STRING
    local Size = #Array

    for Index, Value in ipairs(Array) do
        Result ..= tostring(Value)

        if (Index &lt; Size) then
            Result ..= Separator
        end
    end

    return Result
end

local STRUCTURE_TO_FLAT_STRING_MT = {
    __tostring = function(self)
        local Pairings = {}

        for Key, Value in pairs(self) do
            table.insert(Pairings, tostring(Key) .. " = " .. tostring(Value))
        end

        return "{" .. ConcatWithToString(Pairings, ", ") .. "}"
    end;
}

-- Standard re-usable functions throughout all type checkers
    local function IsAKeyIn&lt;T>(self: T, ...)
        return self:_AddConstraint("IsAKeyIn", function(_, Key, Store)
            return Store[Key] ~= nil, "No key found in table: " .. tostring(Store)
        end, ...)
    end

    local function IsAValueIn&lt;T>(self: T, ...)
        return self:_AddConstraint("IsAValueIn", function(_, TargetValue, Store)
            for _, Value in pairs(Store) do
                if (Value == TargetValue) then
                    return true, EMPTY_STRING
                end
            end

            return false, "No value found in table: " .. tostring(Store)
        end, ...)
    end

    local function Equals&lt;T>(self: T, ...)
        return self:_AddConstraint("Equals", function(_, Value, ExpectedValue)
            return Value == ExpectedValue, "Value " .. tostring(Value) .. " does not equal " .. tostring(ExpectedValue)
        end, ...)
    end

    local function GreaterThan&lt;T>(self: T, ...)
        return self:_AddConstraint("GreaterThan", function(_, Value, ExpectedValue)
            return Value > ExpectedValue, "Value " .. tostring(Value) .. " is not greater than " .. tostring(ExpectedValue)
        end, ...)
    end

    local function LessThan&lt;T>(self: T, ...)
        return self:_AddConstraint("LessThan", function(_, Value, ExpectedValue)
            return Value &lt; ExpectedValue, "Value " .. tostring(Value) .. " is not less than " .. tostring(ExpectedValue)
        end, ...)
    end





local TypeGuard = {}

type SelfReturn&lt;T, P...> = ((T, P...) -> T)

type TypeCheckerObject&lt;T> = {
    _Copy: SelfReturn&lt;TypeCheckerObject&lt;T>>;
    _AddConstraint: SelfReturn&lt;TypeCheckerObject&lt;T>, string, (any) -> (TypeCheckerObject&lt;T>), ...any>;

    Or: SelfReturn&lt;TypeCheckerObject&lt;T>, TypeCheckerObject&lt;any>>;
    And: SelfReturn&lt;TypeCheckerObject&lt;T>, TypeCheckerObject&lt;any>>;
    Alias: SelfReturn&lt;TypeCheckerObject&lt;T>, string>;
    AddTag: SelfReturn&lt;TypeCheckerObject&lt;T>, string>;
    Optional: SelfReturn&lt;TypeCheckerObject&lt;T>>;

    WrapCheck: (TypeCheckerObject&lt;T>) -> ((any) -> (boolean, string));
    WrapAssert: (TypeCheckerObject&lt;T>) -> ((any) -> ());
    Check: (TypeCheckerObject&lt;T>, any) -> (string, boolean);
    Assert: (TypeCheckerObject&lt;T>, any) -> ();

    -- Standard constraints
    Equals: SelfReturn&lt;TypeCheckerObject&lt;T>, any>;
    equals: SelfReturn&lt;TypeCheckerObject&lt;T>, any>;

    IsAValueIn: SelfReturn&lt;TypeCheckerObject&lt;T>, any>;
    isAValueIn: SelfReturn&lt;TypeCheckerObject&lt;T>, any>;

    IsAKeyIn: SelfReturn&lt;TypeCheckerObject&lt;T>, any>;
    isAKeyIn: SelfReturn&lt;TypeCheckerObject&lt;T>, any>;

    GreaterThan: SelfReturn&lt;TypeCheckerObject&lt;T>, number>;
    greaterThan: SelfReturn&lt;TypeCheckerObject&lt;T>, number>;

    LessThan: SelfReturn&lt;TypeCheckerObject&lt;T>, number>;
    lessThan: SelfReturn&lt;TypeCheckerObject&lt;T>, number>;
}

function TypeGuard.Template(Name)
    ExpectType(Name, "string", 1)

    local TemplateClass = {}
    TemplateClass.__index = TemplateClass
    TemplateClass._IsTemplate = true
    TemplateClass._InitialConstraint = nil
    TemplateClass._Type = Name

    function TemplateClass.new(...)
        local self = {
            _Tags = {};
            _Disjunction = {};
            _Conjunction = {};
            _ActiveConstraints = {};
        }

        setmetatable(self, TemplateClass)

        if (TemplateClass._InitialConstraint and select("#", ...) > 0) then
            return self:_InitialConstraint(...)
        end

        return self
    end

    function TemplateClass:_Copy()
        local New = TemplateClass.new()

        -- Copy tags
        for Key, Value in pairs(self._Tags) do
            New._Tags[Key] = Value
        end

        -- Copy OR
        for Index, Disjunction in ipairs(self._Disjunction) do
            New._Disjunction[Index] = Disjunction
        end

        -- Copy AND
        for Index, Conjunction in ipairs(self._Conjunction) do
            New._Conjunction[Index] = Conjunction
        end

        -- Copy constraints
        for ConstraintName, Constraint in pairs(self._ActiveConstraints) do
            New._ActiveConstraints[ConstraintName] = Constraint
        end

        return New
    end

    -- TODO: only 1 constraint of each type
    function TemplateClass:_AddConstraint(ConstraintName, Constraint, ...)
        ExpectType(ConstraintName, "string", 1)
        ExpectType(Constraint, "function", 2)

        self = self:_Copy()

        local ActiveConstraints = self._ActiveConstraints
        assert(ActiveConstraints[ConstraintName] == nil, "Constraint already exists: " .. ConstraintName)
        ActiveConstraints[ConstraintName] = {Constraint, {...}}
        return self
    end

    function TemplateClass:Optional()
        return self:AddTag("Optional")
    end

    function TemplateClass:Or(OtherType)
        TypeGuard._AssertIsTypeBase(OtherType)

        self = self:_Copy()
        table.insert(self._Disjunction, OtherType)
        return self
    end

    function TemplateClass:And(OtherType)
        TypeGuard._AssertIsTypeBase(OtherType)

        self = self:_Copy()
        table.insert(self._Conjunction, OtherType)
        return self
    end

    function TemplateClass:Alias(AliasName)
        ExpectType(AliasName, "string", 1)

        self = self:_Copy()
        self._Alias = AliasName
        return self
    end

    function TemplateClass:AddTag(TagName)
        ExpectType(TagName, "string", 1)

        self = self:_Copy()
        self._Tags[TagName] = true
        return self
    end

    function TemplateClass:WrapCheck()
        return function(...)
            return self:Check(...)
        end
    end

    function TemplateClass:WrapAssert()
        return function(...)
            return self:Assert(...)
        end
    end

    function TemplateClass:Check(Value)
        -- Handle "type x or type y or type z ..."
        -- We do this before checking constraints to check if any of the other conditions succeed
        local Disjunctions = self._Disjunction
        local DidTryDisjunction = (Disjunctions[1] ~= nil)

        for _, AlternateType in ipairs(Disjunctions) do
            local Success, _ = AlternateType:Check(Value)

            if (Success) then
                return true, EMPTY_STRING
            end
        end

        -- Handle "type x and type y and type z ..." - this is only really useful for objects and arrays
        for _, Conjunction in ipairs(self._Conjunction) do
            local Success, Message = Conjunction:Check(Value)

            if (not Success) then
                return false, "[Conjunction " .. tostring(Conjunction) .. "] " .. Message
            end
        end

        -- Optional allows the value to be nil, in which case it won't be checked and we can resolve
        if (self._Tags.Optional and Value == nil) then
            return true, EMPTY_STRING
        end

        -- Handle initial type check
        local Success, Message = self:_Initial(Value)

        if (not Success) then
            if (DidTryDisjunction) then
                return false, "Disjunctions failed on " .. tostring(self)
            else
                return false, Message
            end
        end

        -- Handle active constraints
        for _, Constraint in pairs(self._ActiveConstraints) do
            local SubSuccess, SubMessage = Constraint[1](self, Value, unpack(Constraint[2]))

            if (not SubSuccess) then
                if (DidTryDisjunction) then
                    return false, "Disjunctions failed on " .. tostring(self)
                else
                    return false, SubMessage
                end
            end
        end

        return true, EMPTY_STRING
    end

    function TemplateClass:Assert(...)
        assert(self:Check(...))
    end

    function TemplateClass:__tostring()
        -- User can create a unique alias to help simplify "where did it fail?"
        if (self._Alias) then
            return self._Alias
        end

        local Fields = {}

        -- Constraints list (including arg, possibly other type defs)
        if (next(self._ActiveConstraints) ~= nil) then
            local InnerConstraints = {}

            for ConstraintName, Constraint in pairs(self._ActiveConstraints) do
                table.insert(InnerConstraints, ConstraintName .. "(" .. ConcatWithToString(Constraint[2], ", ") .. ")")
            end

            table.insert(Fields, "Constraints = {" .. ConcatWithToString(InnerConstraints, ", ") .. "}")
        end

        -- Alternatives field str
        if (#self._Disjunction > 0) then
            local Alternatives = {}

            for _, AlternateType in ipairs(self._Disjunction) do
                table.insert(Alternatives, tostring(AlternateType))
            end

            table.insert(Fields, "Or = {" .. ConcatWithToString(Alternatives, ", ") .. "}")
        end

        -- Union fields str
        if (#self._Conjunction > 0) then
            local Unions = {}

            for _, Union in ipairs(self._Conjunction) do
                table.insert(Unions, tostring(Union))
            end

            table.insert(Fields, "And = {" .. ConcatWithToString(Unions, ", ") .. "}")
        end

        -- Tags (e.g. Optional, Strict)
        if (next(self._Tags) ~= nil) then
            local Tags = {}

            for Tag in pairs(self._Tags) do
                table.insert(Tags, Tag)
            end

            table.insert(Fields, "Tags = {" .. ConcatWithToString(Tags, ", ") .. "}")
        end

        return self._Type .. "(" .. ConcatWithToString(Fields, ", ") .. ")"
    end

    TemplateClass.Equals = Equals
    TemplateClass.equals = Equals

    TemplateClass.IsAValueIn = IsAValueIn
    TemplateClass.isAValueIn = IsAValueIn

    TemplateClass.IsAKeyIn = IsAKeyIn
    TemplateClass.isAKeyIn = IsAKeyIn

    TemplateClass.GreaterThan = GreaterThan
    TemplateClass.greaterThan = GreaterThan

    TemplateClass.LessThan = LessThan
    TemplateClass.lessThan = LessThan

    return function(...)
        return TemplateClass.new(...)
    end, TemplateClass
end

--- Checks if an object contains the fields which define a type template from this module
function TypeGuard._AssertIsTypeBase(Subject)
    ExpectType(Subject, "table", 1)

    assert(Subject._Tags ~= nil, "Subject does not contain _Tags field")
    assert(Subject._ActiveConstraints ~= nil, "Subject does not contain _ActiveConstraints field")
    assert(Subject._Disjunction ~= nil, "Subject does not contain _Disjunction field")
    assert(Subject._Conjunction ~= nil, "Subject does not contain _Conjunction field")
end

--- Cheap &amp; easy way to create a type without any constraints, and just an initial check corresponding to Roblox's typeof
function TypeGuard.FromTypeName(TypeName)
    ExpectType(TypeName, "string", 1)

    local CheckerFunction, CheckerClass = TypeGuard.Template(TypeName)
    CheckerClass._Initial = CreateStandardInitial(TypeName)
    return CheckerFunction
end
TypeGuard.fromTypeName = TypeGuard.FromTypeName




do
    type NumberTypeCheckerObject = {
        Integer: SelfReturn&lt;NumberTypeCheckerObject>;
        integer: SelfReturn&lt;NumberTypeCheckerObject>;

        Decimal: SelfReturn&lt;NumberTypeCheckerObject>;
        decimal: SelfReturn&lt;NumberTypeCheckerObject>;

        Min: SelfReturn&lt;NumberTypeCheckerObject, number>;
        min: SelfReturn&lt;NumberTypeCheckerObject, number>;

        Max: SelfReturn&lt;NumberTypeCheckerObject, number>;
        max: SelfReturn&lt;NumberTypeCheckerObject, number>;

        Range: SelfReturn&lt;NumberTypeCheckerObject, number, number>;
        range: SelfReturn&lt;NumberTypeCheckerObject, number, number>;

        Positive: SelfReturn&lt;NumberTypeCheckerObject>;
        positive: SelfReturn&lt;NumberTypeCheckerObject>;

        Negative: SelfReturn&lt;NumberTypeCheckerObject>;
        negative: SelfReturn&lt;NumberTypeCheckerObject>;
    } &amp; TypeCheckerObject&lt;NumberTypeCheckerObject>

    local Number: SelfReturn&lt;NumberTypeCheckerObject>, NumberClass = TypeGuard.Template("Number")

    function NumberClass:_Initial(Item)
        return typeof(Item) == "number", "Expected number, got " .. typeof(Item)
    end

    function NumberClass:Integer(...)
        return self:_AddConstraint("Integer", function(_, Item)
            return math.floor(Item) == Item, "Expected integer form, got " .. tostring(Item)
        end, ...)
    end
    NumberClass.integer = NumberClass.Integer

    function NumberClass:Decimal(...)
        return self:_AddConstraint("Decimal", function(_, Item)
            return math.floor(Item) ~= Item, "Expected decimal form, got " .. tostring(Item)
        end, ...)
    end
    NumberClass.decimal = NumberClass.Decimal

    function NumberClass:Min(...)
        return self:_AddConstraint("Min", function(_, Item, Min)
            return Item >= Min, "Length must be at least " .. tostring(Min) .. ", got " .. tostring(Item)
        end, ...)
    end
    NumberClass.min = NumberClass.Min

    function NumberClass:Max(...)
        return self:_AddConstraint("Max", function(_, Item, Max)
            return Item &lt;= Max, "Length must be at most " .. tostring(Max) .. ", got " .. tostring(Item)
        end, ...)
    end
    NumberClass.max = NumberClass.Max

    function NumberClass:Range(...)
        return self:_AddConstraint("Range", function(_, Item, Min, Max)
            return Item >= Min and Item &lt;= Max, "Length must be between " .. tostring(Min) .. " and " .. tostring(Max) .. ", got " .. tostring(Item)
        end, ...)
    end
    NumberClass.range = NumberClass.Range

    function NumberClass:Positive(...)
        return self:_AddConstraint("Positive", function(_, Item)
            return Item >= 0, "Expected positive number, got " .. tostring(Item)
        end, ...)
    end
    NumberClass.positive = NumberClass.Positive

    function NumberClass:Negative(...)
        return self:_AddConstraint("Negative", function(_, Item)
            return Item &lt; 0, "Expected negative number, got " .. tostring(Item)
        end, ...)
    end
    NumberClass.negative = NumberClass.Negative

    TypeGuard.Number = Number
    TypeGuard.number = Number
end




do
    type StringTypeCheckerObject = TypeCheckerObject&lt;StringTypeCheckerObject> &amp; {
        MinLength: SelfReturn&lt;StringTypeCheckerObject, number>;
        minLength: SelfReturn&lt;StringTypeCheckerObject, number>;

        MaxLength: SelfReturn&lt;StringTypeCheckerObject, number>;
        maxLength: SelfReturn&lt;StringTypeCheckerObject, number>;

        Pattern: SelfReturn&lt;StringTypeCheckerObject, string>;
        pattern: SelfReturn&lt;StringTypeCheckerObject, string>;
    }

    local String: SelfReturn&lt;StringTypeCheckerObject>, StringClass = TypeGuard.Template("String")
    StringClass._Initial = CreateStandardInitial("string")

    function StringClass:MinLength(...)
        return self:_AddConstraint("MinLength", function(_, Item, MinLength)
            return #Item >= MinLength, "Length must be at least " .. MinLength .. ", got " .. #Item
        end, ...)
    end
    StringClass.minLength = StringClass.MinLength

    function StringClass:MaxLength(...)
        return self:_AddConstraint("MaxLength", function(_, Item, MaxLength)
            return #Item &lt;= MaxLength, "Length must be at most " .. MaxLength .. ", got " .. #Item
        end, ...)
    end
    StringClass.maxLength = StringClass.MaxLength

    function StringClass:Pattern(...)
        return self:_AddConstraint("Pattern", function(_, Item, Pattern)
            return string.match(Item, Pattern) ~= nil, "String does not match pattern " .. tostring(Pattern)
        end, ...)
    end
    StringClass.pattern = StringClass.Pattern

    TypeGuard.String = String
    TypeGuard.string = String
end




do
    local PREFIX_ARRAY = "Index"
    local PREFIX_PARAM = "Param"
    local ERR_PREFIX = "[%s '%d'] "
    local ERR_UNEXPECTED_VALUE = ERR_PREFIX .. " Unexpected value (strict tag is present)"

    type ArrayTypeCheckerObject = TypeCheckerObject&lt;ArrayTypeCheckerObject> &amp; {
        OfLength: SelfReturn&lt;ArrayTypeCheckerObject, number>;
        ofLength: SelfReturn&lt;ArrayTypeCheckerObject, number>;

        MinLength: SelfReturn&lt;ArrayTypeCheckerObject, number>;
        minLength: SelfReturn&lt;ArrayTypeCheckerObject, number>;

        MaxLength: SelfReturn&lt;ArrayTypeCheckerObject, number>;
        maxLength: SelfReturn&lt;ArrayTypeCheckerObject, number>;

        Contains: SelfReturn&lt;ArrayTypeCheckerObject, any>;
        contains: SelfReturn&lt;ArrayTypeCheckerObject, any>;

        OfType: SelfReturn&lt;ArrayTypeCheckerObject, TypeCheckerObject&lt;any>>;
        ofType: SelfReturn&lt;ArrayTypeCheckerObject, TypeCheckerObject&lt;any>>;

        OfStructure: SelfReturn&lt;ArrayTypeCheckerObject, {TypeCheckerObject&lt;any>}>;
        ofStructure: SelfReturn&lt;ArrayTypeCheckerObject, {TypeCheckerObject&lt;any>}>;

        StructuralEquals: SelfReturn&lt;ArrayTypeCheckerObject, {TypeCheckerObject&lt;any>}>;
        structuralEquals: SelfReturn&lt;ArrayTypeCheckerObject, {TypeCheckerObject&lt;any>}>;

        Strict: SelfReturn&lt;ArrayTypeCheckerObject>;
        strict: SelfReturn&lt;ArrayTypeCheckerObject>;
    }

    local Array: SelfReturn&lt;ArrayTypeCheckerObject>, ArrayClass = TypeGuard.Template("Array")

    function ArrayClass:_PrefixError(ErrorString: string, Index: number)
        return ErrorString:format((self._Tags.DenoteParams and PREFIX_PARAM or PREFIX_ARRAY), Index)
    end

    function ArrayClass:_Initial(TargetArray)
        if (typeof(TargetArray) ~= "table") then
            return false, "Expected table, got " .. typeof(TargetArray)
        end

        for Key in pairs(TargetArray) do
            local KeyType = typeof(Key)

            if (KeyType ~= "number") then
                return false, "Non-numetic key detected: " .. KeyType
            end
        end

        return true, EMPTY_STRING
    end

    function ArrayClass:OfLength(...)
        return self:_AddConstraint("Length", function(_, TargetArray, Length)
            return #TargetArray == Length, "Length must be " .. Length .. ", got " .. #TargetArray
        end, ...)
    end
    ArrayClass.ofLength = ArrayClass.OfLength

    function ArrayClass:MinLength(...)
        return self:_AddConstraint("MinLength", function(_, TargetArray, MinLength)
            return #TargetArray >= MinLength, "Length must be at least " .. MinLength .. ", got " .. #TargetArray
        end, ...)
    end
    ArrayClass.minLength = ArrayClass.MinLength

    function ArrayClass:MaxLength(...)
        return self:_AddConstraint("MaxLength", function(_, TargetArray, MaxLength)
            return #TargetArray &lt;= MaxLength, "Length must be at most " .. MaxLength .. ", got " .. #TargetArray
        end, ...)
    end
    ArrayClass.maxLength = ArrayClass.MaxLength

    function ArrayClass:Contains(...)
        return self:_AddConstraint("Contains", function(_, TargetArray, Value, StartPoint)
            return table.find(TargetArray, Value, StartPoint) ~= nil, "Value not found in array: " .. tostring(Value)
        end, ...)
    end
    ArrayClass.contains = ArrayClass.Contains

    function ArrayClass:OfType(...)
        return self:_AddConstraint("OfType", function(SelfRef, TargetArray, SubType)
            for Index, Value in ipairs(TargetArray) do
                local Success, SubMessage = SubType:Check(Value)

                if (not Success) then
                    return false, ERR_PREFIX:format((SelfRef._Tags.DenoteParams and PREFIX_PARAM or PREFIX_ARRAY), tostring(Index)) .. SubMessage
                end
            end

            return true, EMPTY_STRING
        end, ...)
    end
    ArrayClass.ofType = ArrayClass.OfType

    function ArrayClass:OfStructure(ArrayToCheck, ...)
        -- Just in case the user does any weird mutation
        local SubTypesCopy = {}

        for Key, Value in ipairs(ArrayToCheck) do
            SubTypesCopy[Key] = Value
        end

        setmetatable(SubTypesCopy, STRUCTURE_TO_FLAT_STRING_MT)

        return self:_AddConstraint("OfStructure", function(SelfRef, TargetArray, SubTypesAtPositions)
            -- Check all fields which should be in the object exist (unless optional) and the type check for each passes
            for Index, Checker in ipairs(SubTypesAtPositions) do
                local Success, SubMessage = Checker:Check(TargetArray[Index])

                if (not Success) then
                    return false, self:_PrefixError(ERR_PREFIX, tostring(Index)) .. SubMessage
                end
            end

            -- Check there are no extra indexes which shouldn't be in the object
            if (SelfRef._Tags.Strict) then
                for Index in ipairs(TargetArray) do
                    local Checker = SubTypesAtPositions[Index]

                    if (not Checker) then
                        return false, self:_PrefixError(ERR_UNEXPECTED_VALUE, tostring(Index))
                    end
                end
            end

            return true, EMPTY_STRING
        end, SubTypesCopy, ...)
    end
    ArrayClass.ofStructure = ArrayClass.OfStructure

    function ArrayClass:StructuralEquals(Other)
        return self:OfStructure(Other):Strict()
    end
    ArrayClass.structuralEquals = ArrayClass.StructuralEquals

    function ArrayClass:Strict()
        return self:AddTag("Strict")
    end
    ArrayClass.strict = ArrayClass.Strict

    function ArrayClass:DenoteParams()
        return self:AddTag("DenoteParams")
    end
    ArrayClass.denoteParams = ArrayClass.DenoteParams

    ArrayClass._InitialConstraint = ArrayClass.OfType

    TypeGuard.Array = Array
end




do
    type ObjectTypeCheckerObject = TypeCheckerObject&lt;ObjectTypeCheckerObject> &amp; {
        OfStructure: SelfReturn&lt;ObjectTypeCheckerObject, {[any]: TypeCheckerObject&lt;any>}>;
        ofStructure: SelfReturn&lt;ObjectTypeCheckerObject, {[any]: TypeCheckerObject&lt;any>}>;

        StructuralEquals: SelfReturn&lt;ObjectTypeCheckerObject, {[any]: TypeCheckerObject&lt;any>}>;
        structuralEquals: SelfReturn&lt;ObjectTypeCheckerObject, {[any]: TypeCheckerObject&lt;any>}>;

        Strict: SelfReturn&lt;ObjectTypeCheckerObject>;
        strict: SelfReturn&lt;ObjectTypeCheckerObject>;

        OfValueType: SelfReturn&lt;ObjectTypeCheckerObject, TypeCheckerObject&lt;any>>;
        ofValueType: SelfReturn&lt;ObjectTypeCheckerObject, TypeCheckerObject&lt;any>>;

        OfKeyType: SelfReturn&lt;ObjectTypeCheckerObject, TypeCheckerObject&lt;any>>;
        ofKeyType: SelfReturn&lt;ObjectTypeCheckerObject, TypeCheckerObject&lt;any>>;
    }

    local Object: SelfReturn&lt;ObjectTypeCheckerObject>, ObjectClass = TypeGuard.Template("Object")

    function ObjectClass:_Initial(TargetObject)
        if (typeof(TargetObject) ~= "table") then
            return false, "Expected table, got " .. typeof(TargetObject)
        end

        for Key in pairs(TargetObject) do
            if (typeof(Key) == "number") then
                return false, "Incorrect key type: number"
            end
        end

        return true, EMPTY_STRING
    end

    function ObjectClass:OfStructure(OriginalSubTypes)
        -- Just in case the user does any weird mutation
        local SubTypesCopy = {}

        for Key, Value in pairs(OriginalSubTypes) do
            SubTypesCopy[Key] = Value
        end

        setmetatable(SubTypesCopy, STRUCTURE_TO_FLAT_STRING_MT)

        return self:_AddConstraint("OfStructure", function(SelfRef, StructureCopy, SubTypes)
            -- Check all fields which should be in the object exist (unless optional) and the type check for each passes
            for Key, Checker in pairs(SubTypes) do
                local RespectiveValue = StructureCopy[Key]

                if (RespectiveValue == nil and not Checker._Tags.Optional) then
                    return false, "[Key '" .. tostring(Key) .. "'] is nil"
                end

                local Success, SubMessage = Checker:Check(RespectiveValue)

                if (not Success) then
                    return false, "[Key '" .. tostring(Key) .. "'] " .. SubMessage
                end
            end

            -- Check there are no extra fields which shouldn't be in the object
            if (SelfRef._Tags.Strict) then
                for Key in pairs(StructureCopy) do
                    local Checker = SubTypes[Key]

                    if (not Checker) then
                        return false, "[Key '" .. tostring(Key) .. "'] unexpected (strict)"
                    end
                end
            end

            return true, EMPTY_STRING
        end, SubTypesCopy)
    end
    ObjectClass.ofStructure = ObjectClass.OfStructure

    function ObjectClass:OfValueType(...)
        return self:_AddConstraint("OfValueType", function(_, TargetArray, SubType)
            for Index, Value in pairs(TargetArray) do
                local Success, SubMessage = SubType:Check(Value)

                if (not Success) then
                    return false, "[OfValueType: Key '" .. tostring(Index) .. "'] " .. SubMessage
                end
            end

            return true, EMPTY_STRING
        end, ...)
    end
    ObjectClass.ofValueType = ObjectClass.OfValueType

    function ObjectClass:OfKeyType(...)
        return self:_AddConstraint("OfKeyType", function(_, TargetArray, SubType)
            for Index, Value in pairs(TargetArray) do
                local Success, SubMessage = SubType:Check(Value)

                if (not Success) then
                    return false, "[OfKeyType: Key '" .. tostring(Index) .. "'] " .. SubMessage
                end
            end

            return true, EMPTY_STRING
        end, ...)
    end
    ObjectClass.ofKeyType = ObjectClass.OfKeyType

    function ObjectClass:Strict()
        return self:AddTag("Strict")
    end
    ObjectClass.strict = ObjectClass.Strict

    function ObjectClass:StructuralEquals(...)
        return self:OfStructure(...):Strict()
    end
    ObjectClass.structuralEquals = ObjectClass.StructuralEquals

    ObjectClass._InitialConstraint = ObjectClass.OfStructure

    TypeGuard.Object = Object
end




do
    type InstanceTypeCheckerObject = TypeCheckerObject&lt;InstanceTypeCheckerObject> &amp; {
        OfStructure: SelfReturn&lt;InstanceTypeCheckerObject, {[any]: TypeCheckerObject&lt;Instance>}>;
        ofStructure: SelfReturn&lt;InstanceTypeCheckerObject, {[any]: TypeCheckerObject&lt;Instance>}>;

        StructuralEquals: SelfReturn&lt;InstanceTypeCheckerObject, {[any]: TypeCheckerObject&lt;Instance>}>;
        structuralEquals: SelfReturn&lt;InstanceTypeCheckerObject, {[any]: TypeCheckerObject&lt;Instance>}>;

        IsA: SelfReturn&lt;InstanceTypeCheckerObject, string>;
        isA: SelfReturn&lt;InstanceTypeCheckerObject, string>;

        CheckProperty: SelfReturn&lt;InstanceTypeCheckerObject, string, TypeCheckerObject&lt;any>>;
        checkProperty: SelfReturn&lt;InstanceTypeCheckerObject, string, TypeCheckerObject&lt;any>>;

        Strict: SelfReturn&lt;InstanceTypeCheckerObject>;
        strict: SelfReturn&lt;InstanceTypeCheckerObject>;
    }

    local InstanceChecker: SelfReturn&lt;InstanceTypeCheckerObject>, InstanceCheckerClass = TypeGuard.Template("Instance")
    InstanceCheckerClass._Initial = CreateStandardInitial("Instance")

    function InstanceCheckerClass:OfStructure(OriginalSubTypes)
        -- Just in case the user does any weird mutation
        local SubTypesCopy = {}

        for Key, Value in pairs(OriginalSubTypes) do
            SubTypesCopy[Key] = Value
        end

        setmetatable(SubTypesCopy, STRUCTURE_TO_FLAT_STRING_MT)

        return self:_AddConstraint("OfStructure", function(SelfRef, InstanceRoot, SubTypes)
            -- Check all fields which should be in the object exist (unless optional) and the type check for each passes
            for Key, Checker in pairs(SubTypes) do
                local Success, SubMessage = Checker:Check(InstanceRoot:FindFirstChild(Key))

                if (not Success) then
                    return false, "[Instance '" .. tostring(Key) .. "'] " .. SubMessage
                end
            end

            -- Check there are no extra fields which shouldn't be in the object
            if (SelfRef._Tags.Strict) then
                for _, Value in ipairs(InstanceRoot:GetChildren()) do
                    local Key = Value.Name
                    local Checker = SubTypes[Key]

                    if (not Checker) then
                        return false, "[Instance '" .. tostring(Key) .. "'] unexpected (strict)"
                    end
                end
            end

            return true, EMPTY_STRING
        end, SubTypesCopy)
    end
    InstanceCheckerClass.ofStructure = InstanceCheckerClass.OfStructure

    function InstanceCheckerClass:IsA(...)
        return self:_AddConstraint("IsA", function(_, InstanceRoot, InstanceIsA)
            if (not InstanceRoot:IsA(InstanceIsA)) then
                return false, "Expected " .. InstanceIsA .. ", got " .. InstanceRoot.ClassName
            end

            return true, EMPTY_STRING
        end, ...)
    end
    InstanceCheckerClass.isA = InstanceCheckerClass.IsA

    function InstanceCheckerClass:CheckProperty(...)
        return self:_AddConstraint("CheckProperty", function(_, InstanceRoot, PropertyName, Checker)
            return Checker:Check(InstanceRoot[PropertyName])
        end, ...)
    end
    InstanceCheckerClass.checkProperty = InstanceCheckerClass.CheckProperty

    function InstanceCheckerClass:Strict()
        return self:AddTag("Strict")
    end
    InstanceCheckerClass.strict = InstanceCheckerClass.Strict

    function InstanceCheckerClass:StructuralEquals(...)
        return self:OfStructure(...):Strict()
    end
    InstanceCheckerClass.structuralEquals = InstanceCheckerClass.StructuralEquals

    InstanceCheckerClass._InitialConstraint = InstanceCheckerClass.IsA

    TypeGuard.Instance = InstanceChecker
end




do
    type BooleanTypeCheckerObject = TypeCheckerObject&lt;BooleanTypeCheckerObject> &amp; {
        -- Fill any stuff here in future
    }

    local Boolean: SelfReturn&lt;BooleanTypeCheckerObject>, BooleanClass = TypeGuard.Template("Boolean")
    BooleanClass._Initial = CreateStandardInitial("boolean")

    BooleanClass._InitialConstraint = BooleanClass.Equals

    TypeGuard.Boolean = Boolean
    TypeGuard.boolean = Boolean
end




do
    type EnumTypeCheckerObject = TypeCheckerObject&lt;EnumTypeCheckerObject> &amp; {
        IsA: SelfReturn&lt;EnumTypeCheckerObject, Enum | EnumItem>;
        isA: SelfReturn&lt;EnumTypeCheckerObject, Enum | EnumItem>;
    }

    local EnumChecker: SelfReturn&lt;EnumTypeCheckerObject>, EnumCheckerClass = TypeGuard.Template("Enum")

    function EnumCheckerClass:_Initial(Value)
        local GotType = typeof(Value)

        if (GotType ~= "EnumItem" and GotType ~= "Enum") then
            return false, "Expected EnumItem or Enum, got " .. GotType
        end

        return true, EMPTY_STRING
    end

    function EnumCheckerClass:IsA(...)
        return self:_AddConstraint("IsA", function(_, Value, TargetEnum)
            local PassedType = typeof(Value)
            local TargetType = typeof(TargetEnum)

            -- Both are EnumItems
            if (PassedType == "EnumItem" and TargetType == "EnumItem") then
                return Value == TargetEnum, "Expected " .. tostring(TargetEnum) .. ", got " .. tostring(Value)
            elseif (PassedType == "EnumItem" and TargetType == "Enum") then
                return table.find(TargetEnum:GetEnumItems(), Value) ~= nil, "Expected a " .. tostring(TargetEnum) .. ", got " .. tostring(Value)
            end

            return false, "Invalid comparison: " .. PassedType .. " to " .. TargetType
        end, ...)
    end
    EnumCheckerClass.isA = EnumCheckerClass.IsA

    EnumCheckerClass._InitialConstraint = EnumCheckerClass.IsA

    TypeGuard.Enum = EnumChecker
end




do
    type NilTypeCheckerObject = TypeCheckerObject&lt;NilTypeCheckerObject> &amp; {}

    local NilChecker: SelfReturn&lt;NilTypeCheckerObject>, NilCheckerClass = TypeGuard.Template("Nil")

    function NilCheckerClass:_Initial(Value)
        if (Value == nil) then
            return false, "Expected nil, got " .. typeof(Value)
        end

        return true, EMPTY_STRING
    end

    TypeGuard.Nil = NilChecker
end




TypeGuard.Axes = TypeGuard.FromTypeName("Axes")
TypeGuard.BrickColor = TypeGuard.FromTypeName("BrickColor")
TypeGuard.CatalogSearchParams = TypeGuard.FromTypeName("CatalogSearchParams")
TypeGuard.CFrame = TypeGuard.FromTypeName("CFrame")
TypeGuard.Color3 = TypeGuard.FromTypeName("Color3")
TypeGuard.ColorSequence = TypeGuard.FromTypeName("ColorSequence")
TypeGuard.ColorSequenceKeypoint = TypeGuard.FromTypeName("ColorSequenceKeypoint")
TypeGuard.DateTime = TypeGuard.FromTypeName("DateTime")
TypeGuard.DockWidgetPluginGuiInfo = TypeGuard.FromTypeName("DockWidgetPluginGuiInfo")
TypeGuard.Enums = TypeGuard.FromTypeName("Enums")
TypeGuard.Faces = TypeGuard.FromTypeName("Faces")
TypeGuard.FloatCurveKey = TypeGuard.FromTypeName("FloatCurveKey")
TypeGuard.NumberRange = TypeGuard.FromTypeName("NumberRange")
TypeGuard.NumberSequence = TypeGuard.FromTypeName("NumberSequence")
TypeGuard.NumberSequenceKeypoint = TypeGuard.FromTypeName("NumberSequenceKeypoint")
TypeGuard.OverlapParams = TypeGuard.FromTypeName("OverlapParams")
TypeGuard.PathWaypoint = TypeGuard.FromTypeName("PathWaypoint")
TypeGuard.PhysicalProperties = TypeGuard.FromTypeName("PhysicalProperties")
TypeGuard.Random = TypeGuard.FromTypeName("Random")
TypeGuard.Ray = TypeGuard.FromTypeName("Ray")
TypeGuard.RaycastParams = TypeGuard.FromTypeName("RaycastParams")
TypeGuard.RaycastResult = TypeGuard.FromTypeName("RaycastResult")
TypeGuard.RBXScriptConnection = TypeGuard.FromTypeName("RBXScriptConnection")
TypeGuard.RBXScriptSignal = TypeGuard.FromTypeName("RBXScriptSignal")
TypeGuard.Rect = TypeGuard.FromTypeName("Rect")
TypeGuard.Region3 = TypeGuard.FromTypeName("Region3")
TypeGuard.Region3int16 = TypeGuard.FromTypeName("Region3int16")
TypeGuard.TweenInfo = TypeGuard.FromTypeName("TweenInfo")
TypeGuard.UDim = TypeGuard.FromTypeName("UDim")
TypeGuard.UDim2 = TypeGuard.FromTypeName("UDim2")
TypeGuard.Vector2 = TypeGuard.FromTypeName("Vector2")
TypeGuard.Vector2int16 = TypeGuard.FromTypeName("Vector2int16")
TypeGuard.Vector3 = TypeGuard.FromTypeName("Vector3")
TypeGuard.Vector3int16 = TypeGuard.FromTypeName("Vector3int16")

--- Creates a function which checks params as if they were a strict Array checker
function TypeGuard.Params(...)
    local Params = {...}

    for _, ParamChecker in ipairs(Params) do
        TypeGuard._AssertIsTypeBase(ParamChecker)
    end

    local Checker = TypeGuard.Array():StructuralEquals(Params):DenoteParams()

    return function(...)
        Checker:Assert({...})
    end
end
TypeGuard.params = TypeGuard.Params

--- Creates a function which checks variadic params against a single given type checker
function TypeGuard.VariadicParams(CompareType)
    TypeGuard._AssertIsTypeBase(CompareType)

    local Checker = TypeGuard.Array():OfType(CompareType):DenoteParams()

    return function(...)
        Checker:Assert({...})
    end
end
TypeGuard.variadicParams = TypeGuard.VariadicParams

return TypeGuard</string>
      </Properties>
      <Item class="ModuleScript" referent="2">
        <Properties>
          <string name="Name">TypeGuard.spec</string>
          <string name="Source">-- WIP

return function()
    local TypeGuard = require(script.Parent)

    describe("TypeGuard.Template", function()
        it("should reject no Name given", function()
            expect(function()
                TypeGuard.Template()
            end).to.throw()
        end)

        it("should reject incorrect types for Name", function()
            expect(function()
                TypeGuard.Template(1)
            end).to.throw()

            expect(function()
                TypeGuard.Template({})
            end).to.throw()

            expect(function()
                TypeGuard.Template(true)
            end).to.throw()

            expect(function()
                TypeGuard.Template("Test")
            end).never.to.throw()
        end)

        it("should return a constructor function and a TypeChecker class for extension", function()
            local TestCreate, TestClass = TypeGuard.Template("Test")
            expect(TestCreate).to.be.a("function")
            expect(TestClass).to.be.a("table")

            expect(TestClass._Copy).to.be.ok()
            expect(TestClass._AddConstraint).to.be.ok()
            expect(TestClass.Optional).to.be.ok()
            expect(TestClass.Or).to.be.ok()
            expect(TestClass.And).to.be.ok()
            expect(TestClass.Alias).to.be.ok()
            expect(TestClass.AddTag).to.be.ok()
            expect(TestClass.WrapCheck).to.be.ok()
            expect(TestClass.WrapAssert).to.be.ok()
            expect(TestClass.Check).to.be.ok()
            expect(TestClass.Assert).to.be.ok()
        end)
    end)

    describe("TypeGuard.Params", function()
        it("should reject non-TypeChecker types", function()
            expect(function()
                TypeGuard.Params(1)
            end).to.throw()

            expect(function()
                TypeGuard.Params({})
            end).to.throw()

            expect(function()
                TypeGuard.Params(true)
            end).to.throw()
        end)

        it("should accept TypeChecker types", function()
            expect(function()
                
            end).never.to.throw()
        end)

        it("should check one type", function()
        
        end)

        it("should check multiple types", function()
        
        end)
    end)
end</string>
        </Properties>
      </Item>
    </Item>
  </Item>
</roblox>